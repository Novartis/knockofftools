[{"path":"http://opensource.nibr.com/knockofftools/articles/knockofftools.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The knockofftools package","text":"vignette demonstrate main functionalities knockofftools package. particular, demonstrate functions generating data sets, simulating knockoffs (MX sequential), applying multiple knockoff filter variable selection visualizing selections. Let’s first recall knockoff variable selection methodology works nutshell: Simulate knockoff copy \\(\\tilde{X}\\) original covariates data \\(X\\). Compute feature statistics \\(W_j=|\\beta_j|-|\\tilde{\\beta}_j|\\) aggregated regression \\(Y\\) \\(X\\) \\(\\tilde{X}\\). Large, positive statistics \\(W_j\\) indicate association \\(X_j\\) \\(Y\\). FDR control use knockoffs\\(+\\) procedure select variables \\(j\\) fulfill \\(W_j \\geq \\tau_+\\) \\[ \\tau_+ = \\underset{t>0}{\\operatorname{argmin}} \\left\\{\\frac{1 + |\\{j : W_j \\leq t\\}|}{|\\{j : W_j \\leq t\\}|} \\leq q\\right\\}. \\] workflow selects variables associated response guaranteed control false discovery rate \\(FDR \\leq q\\).","code":"library(knockofftools)"},{"path":"http://opensource.nibr.com/knockofftools/articles/knockofftools.html","id":"simdata","dir":"Articles","previous_headings":"","what":"Data generation","title":"The knockofftools package","text":"section simulate toy data set known truth. particular, simulate set covariates \\(X\\) response \\(y\\) associated \\(X\\)’s regression model. Simulation \\(X\\): generate_X function simulates rows \\(n \\times p\\) data frame \\(X\\) independently multivariate Gaussian distribution mean \\(0\\) \\(p \\times p\\) covariance matrix \\[ \\Sigma_{ij} = \\left \\{ \\begin{array}{lr} 1\\{= j\\}, & \\text{Independent,} \\\\ \\rho^{1\\{\\neq j\\}}, & \\text{Equicorrelated,} \\\\ \\rho^{|-j|}, & \\text{AR1}, \\end{array} \\right. \\] \\(p_b\\) randomly selected columns dichotomized indicator function \\(\\delta(x)=1(x > 0)\\). covariance type specified parameter cov_type correlation coefficient rho. column resulting data.frame either class \"numeric\" (continuous columns) \"factor\" (binary columns). Simulation \\(y|X\\): generate_y function simulates response \\(y\\) (sparse) regression model \\[ y = X \\beta + \\varepsilon, \\textrm{ } \\varepsilon \\sim N(0,I_n), \\] first p_nn regression coefficients non-zero, set zero. (common) amplitude non-zero regression coefficients specified . generate \\(y\\) associated first 10 covariates, amplitude \\(=0.1\\). Note inside generate_y model.matrix X first scaled.","code":"# Generate a 2000 x 30 Gaussian data.frame under equi-correlation(rho=0.5) structure,  # with 10 of the columns dichotomized set.seed(1) X <- generate_X(n=2000, p=30, p_b=10, cov_type = \"cov_equi\", rho=0.5) # Generate y ~ N(X%*%beta,I_n) where first 10 beta-coefficients are = a, all other = 0. y <- generate_y(X = X, p_nn=10, a=0.1)"},{"path":"http://opensource.nibr.com/knockofftools/articles/knockofftools.html","id":"knockoff-generation","dir":"Articles","previous_headings":"","what":"Knockoff generation","title":"The knockofftools package","text":"Sequential knockoffs: function knockoff receives input data.frame (tibble) X whose columns either class \"numeric\" (continuous columns) \"factor\" (categorical columns). common format data involving continuous categorical predictors. output data.frame (tibble) corresponding knockoff copy X: function default sample sequential knockoffs (method=“seq”) based LASSO regression (see (Kormaksson et al. 2021)). Behind scenes, knockoff calls function glmnet::cv.glmnet sequentially. MX-knockoffs: can also simulate Gaussian MX-knockoffs (via call knockoff::create.second_order). function works data frames “numeric” columns. Note practice user really need call knockoff function directly, two main functions knockoff.statistics variable.selections implement full knockoff filter workflow. now discussed .","code":"# Simulate sequential knockoff of X: Xk <- knockoff(X) # Generate a 2000 x 30 Gaussian data.frame under equi-correlation(rho=0.5) structure,  X <- generate_X(n=2000, p=30, p_b=0, cov_type = \"cov_equi\", rho=0.5) # Simulate second order multivariate Gaussian MX knockoff: Xk <- knockoff(X, method=\"mx\")"},{"path":"http://opensource.nibr.com/knockofftools/articles/knockofftools.html","id":"knockoff-feature-statistics","dir":"Articles","previous_headings":"","what":"Knockoff (feature) statistics","title":"The knockofftools package","text":"function knockoff.statistics takes main input y, X, type (defaults type=\"regression\") proceeds 1) simulate independently M knockoffs \\(\\tilde{X}_k\\), \\(k=1,\\dots,M\\), 2) fit aggregated regression model: \\[\\begin{align} Y = X \\beta^{(k)} + \\tilde{X}_k \\tilde{\\beta}^{(k)} + \\varepsilon, \\end{align}\\] \\(k=1,\\dots,M\\) knockoff copies. finally calculate (knockoff \\(k\\)) corresponding knockoff (feature) statistics \\(W^{(k)}_j = |\\beta_j^{(k)}|-|\\tilde{\\beta}_j^{(k)}|\\). changing M parameter knockoff.statistics can calculate multiple knockoff statistics parallel: output W data.frame knockoff statistics across M knockoff replicates. Since knockoff.statistics may take long run single knockoff copy, particular sequential knockoffs (knockoffs.method=“seq”), use parallel computing via package clustermq default. Note user can specify cluster.scheduler system dependent. HPC utilize LSF job scheduler, options (including local parallelization) outlined : User Guide - clustermq","code":"set.seed(123) X <- generate_X(n=2000, p=30, p_b=0, cov_type = \"cov_ar1\", rho=0.5) y <- generate_y(X = X, p_nn=10, 0.1) W <- knockoff.statistics(y, X, M=10)"},{"path":"http://opensource.nibr.com/knockofftools/articles/knockofftools.html","id":"variable-selection-based-on-multiple-knockoff-statistics","dir":"Articles","previous_headings":"","what":"Variable selection based on multiple knockoff statistics","title":"The knockofftools package","text":"calculate variables selected knockoff statistics use variable.selections function. function takes knockoff statistics W input additionally specifies error.type=\"fdr\" (default), \"pfer\" (per family error error), \"kfwer\" (k-familywise error rate) corresponding nominal error level. nutshell function calculate individual variable selections (knockoff replicate), also stable set variables selected frequently among replicates. FDR-control stable variables calculated using heuristics multiple knockoffs filter procedure, two error types (\"pfer\" \"kfwer\") simply choose variables selected thres*M times, thres optional parameter variable.selections function (thres=0.5 default).","code":"S = variable.selections(W, level = 0.1, error.type=\"fdr\") head(S$selected) #>    S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 #> X1  1  1  1  1  1  1  1  1  1   1 #> X2  1  1  1  1  1  1  1  1  1   1 #> X3  1  1  1  1  1  1  1  1  1   1 #> X4  1  1  1  1  1  1  1  1  1   1 #> X5  1  1  1  1  1  1  1  1  1   1 #> X6  1  1  1  1  1  1  1  1  1   1 S$stable.variables #>  [1] \"X1\"  \"X2\"  \"X3\"  \"X4\"  \"X5\"  \"X6\"  \"X7\"  \"X8\"  \"X9\"  \"X10\" \"X12\" \"X20\""},{"path":"http://opensource.nibr.com/knockofftools/articles/knockofftools.html","id":"heatmap-of-multiple-variable-selections","dir":"Articles","previous_headings":"","what":"Heatmap of multiple variable selections","title":"The knockofftools package","text":"order evaluate robustness knockoff selection procedure can visualize heatmap selections across knockoff replicates. apply co-clustering rows columns heatmap order blocks according increasing mean number selections. helps aesthetics, also helps visualize important variables tend towards top heatmap.","code":"plot(S)"},{"path":[]},{"path":"http://opensource.nibr.com/knockofftools/articles/knockofftools.html","id":"multiple-knockoffs-filter-procedure","dir":"Articles","previous_headings":"Appendix","what":"A. The multiple knockoffs filter procedure for FDR-control","title":"The knockofftools package","text":"(Kormaksson et al. 2021) introduced heuristic algorithm selecting stable variables multiple independent knockoff variable selections. Let \\(\\tilde{X}_1, \\dots, \\tilde{X}_B\\) denote \\(B\\) independent knockoff copies \\(X\\). knockoff copy \\(b\\) run knockoff filter select set influential variables, \\(S_b \\subseteq \\{1,\\dots,p\\}\\). propose following heuristics select final set variables: Let \\(F(r) \\subseteq \\{1,\\dots,p\\}\\), \\(r \\[0.5, 1]\\), denote set variables selected \\(r \\cdot B\\) times \\(B\\) knockoff draws. Let \\(S(r)=\\underset{b}{\\rm mode}\\{F(r) \\cap S_b\\}\\) denote set selected variables appears frequently, filtering variables \\(F(r)\\). Return \\(\\hat{S} = S(\\hat{r})\\), \\(\\hat{r} = \\underset{r \\geq 0.5}{\\operatorname{argmax}} |{S(r)}|\\), .e. largest set among \\(\\{S(r):r \\geq 0.5\\}\\). first step essentially filters variables don’t appear \\((100\\cdot r)\\%\\) time, seem like reasonable requirement practice (e.g. \\(r=0.5\\)). second step filters \\(B\\) knockoff selections \\(S_b\\) accordingly searches frequent variable set among . third step establishes final selection, namely liberal variable selection among sets \\(\\{S(r):r \\geq 0.5\\}\\).","code":""},{"path":[]},{"path":"http://opensource.nibr.com/knockofftools/articles/predictive-with-knockoffs.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Deriving predictive variables using knockoffs","text":"vignette demonstrate can use knockofftools identify variables modify treatment effect. particular firstly introduce predictive variables , present various knockoff based filter tailored task identifying predictive variables. details topic can found (Sechidis, Kormaksson, Ohlssen 2021) perform intervention typically two types variables interested . First, prognostic variables, , independent treatment, direct impact target \\(Y.\\) Second, predictive variables, impact outcome interacting treatment explain heterogeneous treatment effect. illustrate distinction two types variables, common approach assume known data generating model (Lipkovich, Dmitrienko, B D’Agostino Sr 2017): \\[\\begin{align} \\mathbb{E}(Y| {X} = \\mathbf{x} ,T = t) = h(\\mathbf{x}) + g(\\mathbf{x})t. \\end{align}\\] Prognostic variables contribute \\(h(\\mathbf{x})\\) (.e., ‘main effects’), predictive ones contribute \\(g(\\mathbf{x})\\). focus vignette predictive variables. show use use two different knockoff filters discover predictive variables, controlling type-error.","code":""},{"path":"http://opensource.nibr.com/knockofftools/articles/predictive-with-knockoffs.html","id":"generate-synthetic-data","dir":"Articles","previous_headings":"","what":"Generate synthetic data","title":"Deriving predictive variables using knockoffs","text":"showing use fitlers generate synthetic data, know thw ground truth, .e. variables predictive. Firstly, load package simulate 50 gaussian covariate predictors. calculate linear predictor prognostic part (\\(h(\\mathbf{x})\\)), first p_nn regression coefficients non-zero, set zero. (common) amplitude non-zero regression coefficients specified . words first p_nn variables prognostic variables. generate binary variable serve treatment indicator. add linear predictor interaction terms, case 6th 7th variable predictive variables. finally, generate outcome variable want filters return 6th 7th variable, since predictive ones, time provide nominal control.","code":"library(knockofftools) X <- generate_X(n=500, p=10, p_b=0, cov_type=\"cov_diag\", rho=0.2) lp <- generate_lp(X, p_nn = 5, a=1) trt = sample(c(1,0), nrow(X), replace=TRUE) lp.pred = lp + 1*trt*( as.integer(X[,6]>0) + as.integer(X[,7]>0)) y <- lp.pred + rnorm(nrow(X))"},{"path":"http://opensource.nibr.com/knockofftools/articles/predictive-with-knockoffs.html","id":"filter-1-using-lasso-regression-coefficients-of-the-treatment-interaction-terms","dir":"Articles","previous_headings":"","what":"Filter 1: Using LASSO regression coefficients of the treatment interaction terms","title":"Deriving predictive variables using knockoffs","text":"One direct way deriving importance scores capture predictive strength variable use LASSO linear model, modelling main interaction effects, check absolute value coefficient interaction terms. knockofftools function stat_predictive_glmnet implements filter follows approach.","code":"W <- knockoff.statistics(y=y, X=X, type=\"regression\", statistic = \"stat_predictive_glmnet\", trt=trt, M=10) #> Running sequentially ('LOCAL') ... S = variable.selections(W, level = 1, error.type=\"pfer\") S$stable.variables #> [1] \"X3\" \"X6\" \"X7\""},{"path":"http://opensource.nibr.com/knockofftools/articles/predictive-with-knockoffs.html","id":"filter-2-using-importance-scores-derived-from-causal-forest","dir":"Articles","previous_headings":"","what":"Filter 2: Using importance scores derived from causal forest","title":"Deriving predictive variables using knockoffs","text":"Causal trees (CT), introduced Athey Imbens (Athey Imbens 2016), recursive partitioning algorithm estimating heterogeneous treatment effects. main difference CT Classification regression trees (CART) CART focus predicting outcome \\(Y,\\) CT focus estimating treatment effect. % example (patient). CT, heterogeneous effects described conditional average treatment effect (CATE): \\(\\mathbb{E} \\left[ Y(1) - Y(0)| {X} = \\mathbf{x}\\right]\\). implemented knockoff filter uses importance scores causal forest derive predictive markers.","code":"W <- knockoff.statistics(y=y, X=X, type=\"regression\", statistic = \"stat_predictive_causal_forest\", trt=trt, M=10) #> Running sequentially ('LOCAL') ... S = variable.selections(W, level = 1, error.type=\"pfer\") S$stable.variables #> character(0)"},{"path":[]},{"path":"http://opensource.nibr.com/knockofftools/articles/simdata.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The simdata dataset","text":"knockofftools package comes simulated data set called simdata. short vignette demonstrates data set generated.","code":"library(knockofftools)"},{"path":"http://opensource.nibr.com/knockofftools/articles/simdata.html","id":"simdata","dir":"Articles","previous_headings":"","what":"Data generation with generate_simdata","title":"The simdata dataset","text":"function generate_simdata used generate data set simdata comes R-package. function simulates toy data set 30 covariates \\(X_1, \\dots, X_{30}\\), one continuous response \\(y_g\\), one binary response \\(y_b\\) one set censored survival times \\(T_c\\). Let’s now go individual components function one one. Simulation \\(X\\): generate_X function simulates rows \\(n \\times p\\) data frame \\(X\\) independently multivariate Gaussian distribution mean \\(0\\) \\(p \\times p\\) covariance matrix \\[ \\Sigma_{ij} = \\left \\{ \\begin{array}{lr} 1\\{= j\\}, & \\text{Independent,} \\\\ \\rho^{1\\{\\neq j\\}}, & \\text{Equicorrelated,} \\\\ \\rho^{|-j|}, & \\text{AR1}, \\end{array} \\right. \\] \\(p_b\\) randomly selected columns dichotomized indicator function \\(\\delta(x)=1(x > 0)\\). covariance type specified parameter cov_type correlation coefficient rho. column resulting data.frame either class \"numeric\" (continuous columns) \"factor\" (binary columns). Calculation linear predictor: generate_lp function calculates linear predictor \\(\\ell_p=X\\beta\\) sparsity, first p_nn regression coefficients non-zero, set zero. (common) amplitude non-zero regression coefficients specified . generate \\(\\ell_p\\) implies association first 10 covariates, amplitude \\(=1\\). Note inside generate_lp model.matrix X first scaled. Simulation Gaussian response: \\(Y_g\\) Gaussian mean \\(\\mu = \\ell_p\\) standard deviation \\(\\sigma = 1\\): Simulation Bernoulli response: \\(Y_b\\) Bernoulli success probability \\(\\mu = exp(\\ell_p)/(1+exp(\\ell_p))\\): Simulation event censoring times: final command: generates censored survival times \\(T_c\\) Cox regression model \\[ \\lambda(t) = \\lambda_0(t) \\exp \\left(\\ell_p \\right), \\] Weibull baseline hazard: \\[ \\lambda_0(t) = \\lambda_0 \\rho t^{\\rho-1} \\] \\(\\lambda_0 > 0\\) \\(\\rho > 0\\) scale shape parameters, respectively. censoring times \\(C\\) randomly drawn exponential distribution small (fixed) rate \\(\\lambda_C=0.0005\\), results mild censoring. \\(T\\) \\(C\\) simulated function returns survival object (Surv) time = min(T, C) event = 1{T < C}:","code":"generate_simdata <- function() {    RNGkind(\"L'Ecuyer-CMRG\")   set.seed(56969)    N <- 2000   p <- 30   p_b = 10   p_nn <- 10    # Generate a 2000 x 30 Gaussian data.frame under equi-correlation(rho=0.5) structure,   # with 10 of the columns dichotomized   X <- generate_X(n=N, p=p, p_b=p_b, cov_type = \"cov_equi\", rho=0.5)    # Generate linear predictor lp = X%*%beta where first 10 beta-coefficients are = a, all other = 0.   lp <- generate_lp(X=X, p_nn=p_nn, a=1)    # simulate gaussian response with mean = lp and sd = 1.   Yg <- lp + rnorm(N)    # simulate bernoulli response with mean = exp(lp)/(1+exp(lp)).   Yb <- factor(rbinom(N, size=1, prob=exp(lp)/(1+exp(lp))))    # simulate censored survival times from Cox regression with linear predictor lp:   Tc <- simulWeib(N=N, lambda = 0.01, rho = 1, lp = lp)    dat <- data.frame(Yg, Yb, Tc, X)    return(dat)  } X <- generate_X(n=N, p=p, p_b=p_b, cov_type = \"cov_equi\", rho=0.5) lp <- generate_lp(X=X, p_nn=p_nn, a=1) Yg <- lp + rnorm(N) Yb <- factor(rbinom(N, size=1, prob=exp(lp)/(1+exp(lp)))) Tc <- simulWeib(N=N, lambda = 0.01, rho = 1, lp = lp) simulWeib <- function(N, lambda0, rho, lp) {     lambdaC = 5e-04     v <- runif(n = N)     Tlat <- (-log(v)/(lambda0 * exp(lp)))^(1/rho)     C <- rexp(n = N, rate = lambdaC)     time <- pmin(Tlat, C)     status <- as.numeric(Tlat <= C)     survival::Surv(time = time, event = status) }"},{"path":"http://opensource.nibr.com/knockofftools/articles/simdata.html","id":"the-data-set-simdata","dir":"Articles","previous_headings":"","what":"The data set simdata","title":"The simdata dataset","text":"Now let’s look first columns data set simdata finally confirm generate_simdata() indeed reproduces simdata dataset:","code":"data(simdata) head(simdata[,1:9]) #>          Yg Yb     Tc.time   Tc.status X1          X2 X3          X4 X5 X6 #> 1 -8.616078  0 2961.163522    0.000000  0 -1.34958449  1 -2.06459293  0  0 #> 2  2.145781  1   14.818694    1.000000  0  1.17359743  1  0.84017766  1  0 #> 3  2.855925  1    5.662159    1.000000  0  0.06617883  1  0.56828582  1  0 #> 4 -7.393736  0  780.165789    0.000000  0  0.60006023  0 -0.88344294  0  0 #> 5 -5.357337  0 1290.810345    0.000000  0  0.68195033  0 -0.07230342  0  1 #> 6  3.720681  1    3.590458    1.000000  1 -0.65766424  1  0.46974365  0  1 all.equal(simdata, generate_simdata()) #> [1] TRUE"},{"path":"http://opensource.nibr.com/knockofftools/articles/survival-analysis-with-knockoffs.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Survival analysis with knockoffs","text":"vignette demonstrate knockoff variable selection context censored time--event data. consider following Cox regression model knockoff variable selection time--event data: \\[\\begin{align} \\lambda(t) = \\lambda_0(t) \\exp \\left(X \\beta + \\tilde{X} \\tilde{\\beta} \\right), \\end{align}\\] \\(\\lambda(t)\\) hazard function corresponding censored time--event response \\(T\\) \\(\\lambda_0(t)\\) baseline hazard. matrix \\(X\\) design matrix corresponding covariates interest, \\(\\tilde{X}\\) represents knockoff copy \\(X\\). Knockoff variable selection Cox regression involves following steps: Simulate knockoff copy \\(\\tilde{X}\\) original covariates data \\(X\\). Compute feature statistics \\(W_j=|\\beta_j|-|\\tilde{\\beta}_j|\\) aggregated Cox regression covariates \\(X\\) \\(\\tilde{X}\\). Large, positive statistics \\(W_j\\) indicate effect \\(X_j\\) hazard rate. FDR control use knockoffs\\(+\\) procedure select variables \\(j\\) fulfill \\(W_j \\geq \\tau_+\\) \\[ \\tau_+ = \\underset{t>0}{\\operatorname{argmin}} \\left\\{\\frac{1 + |\\{j : W_j \\leq t\\}|}{|\\{j : W_j \\leq t\\}|} \\leq q\\right\\}. \\] workflow selects variables associated response guaranteed control false discovery rate \\(FDR \\leq q\\).","code":"library(knockofftools)"},{"path":"http://opensource.nibr.com/knockofftools/articles/survival-analysis-with-knockoffs.html","id":"simdata","dir":"Articles","previous_headings":"","what":"Data generation","title":"Survival analysis with knockoffs","text":"section simulate toy data set known truth. particular, simulate set covariates \\(X\\) survival times censoring associated \\(X\\)’s Cox regression model. Simulation \\(X\\): generate_X function simulates rows \\(n \\times p\\) data frame \\(X\\) independently multivariate Gaussian distribution mean \\(0\\) \\(p \\times p\\) covariance matrix \\[ \\Sigma_{ij} = \\left \\{ \\begin{array}{lr} 1\\{= j\\}, & \\text{Independent,} \\\\ \\rho^{1\\{\\neq j\\}}, & \\text{Equicorrelated,} \\\\ \\rho^{|-j|}, & \\text{AR1}, \\end{array} \\right. \\] \\(p_b\\) randomly selected columns dichotomized indicator function \\(\\delta(x)=1(x > 0)\\). covariance type specified parameter cov_type correlation coefficient rho. column resulting data.frame either class \"numeric\" (continuous columns) \"factor\" (binary columns). Simulation event censoring times: function simulWeib simulates survival times \\(T\\) Cox regression model \\[ \\lambda(t) = \\lambda_0(t) \\exp \\left(X \\beta \\right), \\] Weibull baseline hazard: \\[ \\lambda_0(t) = \\lambda_0 \\rho t^{\\rho-1} \\] \\(\\lambda_0 > 0\\) \\(\\rho > 0\\) scale shape parameters, respectively. censoring times \\(C\\) randomly drawn exponential distribution small (fixed) rate \\(\\lambda_C=0.0005\\), results mild censoring. \\(T\\) \\(C\\) simulated function sets time = min(T, C) event = 1{T < C}: toy data set assume first five covariates affect hazard \\(\\lambda(t)\\) linear predictor \\(\\ell_p=X\\beta\\) simulate survival object:","code":"# Generate a 2000 x 30 Gaussian data.frame under equi-correlation(rho=0.5) structure,  # with 10 of the columns  dichotomized set.seed(1) X <- generate_X(n=2000, p=30, p_b=10, cov_type = \"cov_equi\", rho=0.5) simulWeib <- function(N, lambda0, rho, lp) {     lambdaC = 5e-04     v <- runif(n = N)     Tlat <- (-log(v)/(lambda0 * exp(lp)))^(1/rho)     C <- rexp(n = N, rate = lambdaC)     time <- pmin(Tlat, C)     status <- as.numeric(Tlat <= C)     survival::Surv(time = time, event = status) } lp <- generate_lp(X, p_nn=5, a=2) set.seed(2) y <- simulWeib(N=2000, lambda = 0.01, rho = 1, lp = lp)"},{"path":"http://opensource.nibr.com/knockofftools/articles/survival-analysis-with-knockoffs.html","id":"knockoff-feature-statistics-in-cox-regression","dir":"Articles","previous_headings":"","what":"Knockoff (feature) statistics in Cox regression","title":"Survival analysis with knockoffs","text":"Let’s now use knockoff.statistics function () simulate independently \\(M\\) knockoffs \\(\\tilde{X}_k\\), \\(k=1,\\dots,M\\), (b) fit aggregated Cox model data: \\[\\begin{align} \\lambda(t) = \\lambda_0(t) \\exp \\left(X \\beta^{(k)} + \\tilde{X}_k \\tilde{\\beta}^{(k)} \\right), \\end{align}\\] \\(k=1,\\dots,M\\) knockoff copies. finally calculate (knockoff \\(k\\)) corresponding knockoff (feature) statistics \\(W^{(k)}_j = |\\beta_j^{(k)}|-|\\tilde{\\beta}_j^{(k)}|\\). output data.frame whose columns \\(M\\) knockoff statistics. used (default) parallel computing via package clustermq (see: User Guide - clustermq).","code":"set.seed(123) W <- knockoff.statistics(y, X, type=\"survival\", M=10) head(W) #>             W1          W2         W3        W4         W5          W6 #> X1  1.68417085  1.64920854 1.71294466 1.7130229 1.72623754  1.76959115 #> X2  1.78733106  1.79439991 1.82809127 1.7953936 1.80803144  1.83159085 #> X3  1.74840772  1.75951906 1.80838883 1.7588122 1.75238267  1.80715192 #> X4  1.72546124  1.67708322 1.78064956 1.7258980 1.74789299  1.73426786 #> X5  1.75046697  1.74950657 1.82076525 1.7650704 1.78235237  1.83577773 #> X6 -0.01921297 -0.01275992 0.01461379 0.0156508 0.01742504 -0.01154548 #>            W7         W8         W9          W10 #> X1 1.73428009 1.72061443 1.73521643  1.746217213 #> X2 1.80838108 1.77398820 1.80714829  1.804438638 #> X3 1.76401959 1.74515206 1.77405806  1.829114226 #> X4 1.72333722 1.71313170 1.72602257  1.779804692 #> X5 1.78468873 1.77687033 1.79819418  1.805816339 #> X6 0.00387067 0.01255798 0.01473674 -0.003842216"},{"path":"http://opensource.nibr.com/knockofftools/articles/survival-analysis-with-knockoffs.html","id":"variable-selection-via-multiple-knockoffs","dir":"Articles","previous_headings":"","what":"Variable selection via multiple knockoffs","title":"Survival analysis with knockoffs","text":"simulated \\(M = 10\\) feature statistics order evaluate robustness knockoff variable selection process, time simulating new knockoff X. calculate variables selected knockoff statistics use variable.selections function. function takes knockoff statistics W input additionally specifies error.type=\"fdr\" (default), \"pfer\" (per family error error), \"kfwer\" (k-familywise error rate) corresponding target error level. nutshell function calculate individual variable selections (knockoff replicate) stable set variables selected frequently among M replicates. FDR-control stable variables calculated using heuristics multiple knockoffs filter procedure, two error types (\"pfer\" \"kfwer\") simply choose variables selected thres*M times, thres optional parameter variable.selections function (thres=0.5 default).","code":"S = variable.selections(W, level = 0.2, error.type=\"fdr\") head(S$selected) #>    S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 #> X1  1  1  1  1  1  1  1  1  1   1 #> X2  1  1  1  1  1  1  1  1  1   1 #> X3  1  1  1  1  1  1  1  1  1   1 #> X4  1  1  1  1  1  1  1  1  1   1 #> X5  1  1  1  1  1  1  1  1  1   1 #> X6  0  0  0  1  0  0  0  0  0   0 S$stable.variables #> [1] \"X1\" \"X2\" \"X3\" \"X4\" \"X5\""},{"path":"http://opensource.nibr.com/knockofftools/articles/survival-analysis-with-knockoffs.html","id":"heatmap-of-multiple-variable-selections","dir":"Articles","previous_headings":"","what":"Heatmap of multiple variable selections","title":"Survival analysis with knockoffs","text":"order evaluate robustness knockoff selection procedure can visualize heatmap selections across knockoff replicates. apply co-clustering rows columns heatmap, identifies blocks similarities binary selections. order blocks according increasing mean number selections. helps aesthetics, also helps visualize important variables tend towards top heatmap.","code":"plot(S) #> Warning: Vectorized input to `element_text()` is not officially supported. #> ℹ Results may be unexpected or may change in future versions of ggplot2."},{"path":[]},{"path":"http://opensource.nibr.com/knockofftools/articles/survival-analysis-with-knockoffs.html","id":"multiple-knockoffs-filter-procedure","dir":"Articles","previous_headings":"Appendix","what":"A. The multiple knockoffs filter procedure for FDR-control","title":"Survival analysis with knockoffs","text":"(Kormaksson et al. 2021) introduced heuristic algorithm selecting stable variables multiple independent knockoff variable selections. Let \\(\\tilde{X}_1, \\dots, \\tilde{X}_B\\) denote \\(B\\) independent knockoff copies \\(X\\). knockoff copy \\(b\\) run knockoff filter select set influential variables, \\(S_b \\subseteq \\{1,\\dots,p\\}\\). propose following heuristics select final set variables: Let \\(F(r) \\subseteq \\{1,\\dots,p\\}\\), \\(r \\[0.5, 1]\\), denote set variables selected \\(r \\cdot B\\) times \\(B\\) knockoff draws. Let \\(S(r)=\\underset{b}{\\rm mode}\\{F(r) \\cap S_b\\}\\) denote set selected variables appears frequently, filtering variables \\(F(r)\\). Return \\(\\hat{S} = S(\\hat{r})\\), \\(\\hat{r} = \\underset{r \\geq 0.5}{\\operatorname{argmax}} |{S(r)}|\\), .e. largest set among \\(\\{S(r):r \\geq 0.5\\}\\). first step essentially filters variables don’t appear \\((100\\cdot r)\\%\\) time, seem like reasonable requirement practice (e.g. \\(r=0.5\\)). second step filters \\(B\\) knockoff selections \\(S_b\\) accordingly searches frequent variable set among . third step establishes final selection, namely liberal variable selection among sets \\(\\{S(r):r \\geq 0.5\\}\\).","code":""},{"path":[]},{"path":"http://opensource.nibr.com/knockofftools/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Matthias Kormaksson. Author, maintainer. Kostas Sechidis. Author. Manuela Zimmermann. Author.","code":""},{"path":"http://opensource.nibr.com/knockofftools/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kormaksson M, Sechidis K, Zimmermann M (2024). knockofftools: Knockoffs Utility Tools. R package version 1.0.0, http://opensource.nibr.com/knockofftools/.","code":"@Manual{,   title = {knockofftools: Knockoffs Utility Tools},   author = {Matthias Kormaksson and Kostas Sechidis and Manuela Zimmermann},   year = {2024},   note = {R package version 1.0.0},   url = {http://opensource.nibr.com/knockofftools/}, }"},{"path":"http://opensource.nibr.com/knockofftools/index.html","id":"the-knockofftools-package","dir":"","previous_headings":"","what":"Knockoffs Utility Tools","title":"Knockoffs Utility Tools","text":"suite knockoffs functions methods existing R-packages papers. R functions simple wrapper functions, others novel implementations recent methods.","code":""},{"path":"http://opensource.nibr.com/knockofftools/index.html","id":"invoking-the-r-package-in-development-mode","dir":"","previous_headings":"","what":"Invoking the R-package in development mode","title":"Knockoffs Utility Tools","text":"invoke R-package development mode: please clone repository, set working directory R session, run devtools::load_all().","code":""},{"path":"http://opensource.nibr.com/knockofftools/index.html","id":"how-to-use-knockofftools","dir":"","previous_headings":"","what":"How to use knockofftools","title":"Knockoffs Utility Tools","text":"vignette folder provide various example use cases knockofftools.","code":""},{"path":"http://opensource.nibr.com/knockofftools/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Knockoffs Utility Tools","text":"Knockoff tools introduced Zimmermann et al. 2023). Furthermore, details novel implemented methods can found following papers: Sparse sequential knockoffs Zimmermann et al. (2023) Sequential knockoffs Kormaksson et al. (2021) Predictive knockoffs Sechidis et al. (2021) make use , please cite papers .","code":""},{"path":"http://opensource.nibr.com/knockofftools/index.html","id":"code-authors","dir":"","previous_headings":"","what":"Code authors","title":"Knockoffs Utility Tools","text":"Matthias Kormaksson, matthias-1.kormaksson_ext@novartis.com Konstantinos (Kostas) Sechidis, kostas.sechidis@novartis.com Manuela Zimmermann, manuela.zimmermann@novartis.com","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/causal_forest_importance_scores.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function called to return the importance scores from causal forest — causal_forest_importance_scores","title":"Internal function called to return the importance scores from causal forest — causal_forest_importance_scores","text":"Internal function called return importance scores causal forest","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/causal_forest_importance_scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function called to return the importance scores from causal forest — causal_forest_importance_scores","text":"","code":"causal_forest_importance_scores(   X,   y,   trt,   type = \"regression\",   shuffle = FALSE,   ... )"},{"path":"http://opensource.nibr.com/knockofftools/reference/causal_forest_importance_scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function called to return the importance scores from causal forest — causal_forest_importance_scores","text":"X original data.frame \"numeric\" \"factor\" columns . y response vector length(y) = nrow(X). Accepts \"numeric\" (family=\"gaussian\") binary \"factor\" (family=\"binomial\"). Can also survival object class Surv obtained y = survival::Surv(time, status). trt binary treatment indicator type \"regression\" y numeric, \"classification\" y binary factor variable \"survival\" y survival object. shuffle boolean variable, takes value FALSE want target y shuffled, TRUE otherwise ...","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/causal_forest_importance_scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function called to return the importance scores from causal forest — causal_forest_importance_scores","text":"importance scores","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal check of whether input data frame (or tibble) is of the right format — check_design","title":"Internal check of whether input data frame (or tibble) is of the right format — check_design","text":"call function ","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal check of whether input data frame (or tibble) is of the right format — check_design","text":"","code":"check_design(X, method = \"seq\", check.dim = TRUE)"},{"path":"http://opensource.nibr.com/knockofftools/reference/check_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal check of whether input data frame (or tibble) is of the right format — check_design","text":"X data frame tibble method character string, either \"seq\" \"mx\"","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal check of whether input data frame (or tibble) is of the right format — check_design","text":"function return anything","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_family.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal check of whether class of response is compatible with family — check_family","title":"Internal check of whether class of response is compatible with family — check_family","text":"call function ","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_family.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal check of whether class of response is compatible with family — check_family","text":"","code":"check_family(y, type)"},{"path":"http://opensource.nibr.com/knockofftools/reference/check_family.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal check of whether class of response is compatible with family — check_family","text":"y response variable type \"regression\", \"classification\", \"survival\"","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_family.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal check of whether class of response is compatible with family — check_family","text":"function return anything","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_if_continuous.html","id":null,"dir":"Reference","previous_headings":"","what":"Heuristic check for whether a variable can be reasonably treated as continuous — check_if_continuous","title":"Heuristic check for whether a variable can be reasonably treated as continuous — check_if_continuous","text":"Heuristic check whether variable can reasonably treated continuous","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_if_continuous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Heuristic check for whether a variable can be reasonably treated as continuous — check_if_continuous","text":"","code":"check_if_continuous(X)"},{"path":"http://opensource.nibr.com/knockofftools/reference/check_if_continuous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Heuristic check for whether a variable can be reasonably treated as continuous — check_if_continuous","text":"x numeric variable vector","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_if_continuous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Heuristic check for whether a variable can be reasonably treated as continuous — check_if_continuous","text":"logical TRUE FALSE depending whether n_distinct(x) > 30","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_normality.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal check of normality of the numeric input covariates — check_normality","title":"Internal check of normality of the numeric input covariates — check_normality","text":"call function ","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_normality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal check of normality of the numeric input covariates — check_normality","text":"","code":"check_normality(X)"},{"path":"http://opensource.nibr.com/knockofftools/reference/check_normality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal check of normality of the numeric input covariates — check_normality","text":"X data frame tibble","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/check_normality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal check of normality of the numeric input covariates — check_normality","text":"function return anything","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/cv_coeffs_glmnet_with_fixed_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function called within the stat_glmnet. — cv_coeffs_glmnet_with_fixed_effect","title":"Internal function called within the stat_glmnet. — cv_coeffs_glmnet_with_fixed_effect","text":"call function . Fits cross-validated glmnet model fixed effect.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/cv_coeffs_glmnet_with_fixed_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function called within the stat_glmnet. — cv_coeffs_glmnet_with_fixed_effect","text":"","code":"cv_coeffs_glmnet_with_fixed_effect(   X_fixed,   X,   y,   family,   nlambda = 500,   penalty.factor,   ... )"},{"path":"http://opensource.nibr.com/knockofftools/reference/cv_coeffs_glmnet_with_fixed_effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function called within the stat_glmnet. — cv_coeffs_glmnet_with_fixed_effect","text":"X original data.frame (tibble) \"numeric\" \"factor\" columns . number columns, ncol(X) needs > 2. y response vector length(y) = nrow(X). Accepts \"numeric\" (family=\"gaussian\") binary \"factor\" (family=\"binomial\"). Can also survival object class Surv obtained y = survival::Surv(time, status). family \"gaussian\" y numeric, \"binomial\" y binary factor variable \"cox\" y survival object. nlambda length lambda penalty sequence penalty.factor Separate penalty factors, passed glmnet::cv.glmnet function, can applied coefficient. number multiplies lambda allow differential shrinkage. Can 0 variables, implies shrinkage, variable always included model. ... parameters passed glmnet::cv.glmnet X.fixed data.frame (tibble) \"numeric\" \"factor\" columns corresponding covariates terms treated fixed effects model.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/cv_coeffs_glmnet_with_fixed_effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function called within the stat_glmnet. — cv_coeffs_glmnet_with_fixed_effect","text":"coefficients original knockoff variables","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/dot-knockoff.statistics.single.html","id":null,"dir":"Reference","previous_headings":"","what":"Knockoff (feature) statistics for a single knockoff — .knockoff.statistics.single","title":"Knockoff (feature) statistics for a single knockoff — .knockoff.statistics.single","text":"call function . Use knockoff.statistics instead.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/dot-knockoff.statistics.single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Knockoff (feature) statistics for a single knockoff — .knockoff.statistics.single","text":"","code":".knockoff.statistics.single(   y,   X,   type = \"regression\",   knockoff.method = \"seq\",   statistic = \"stat_glmnet\",   trt = NULL,   adjacency.matrix = NULL,   ... )"},{"path":"http://opensource.nibr.com/knockofftools/reference/dot-knockoff.statistics.single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Knockoff (feature) statistics for a single knockoff — .knockoff.statistics.single","text":"y response vector length(y) = nrow(X). Accepts \"numeric\", binary \"factor\", survival (\"Surv\") object. X data.frame (tibble) \"numeric\" \"factor\" columns . number columns, ncol(X) needs > 2. type \"regression\" y numeric, \"classification\" y binary factor variable \"survival\" y survival object. knockoff.method type knockoffs calculate. Defaults sequential knockoffs, knockoff.method=\"seq\", options \"sparseseq\" \"mx\". \"mx\" option works columns X continuous. statistic knockoff feature statistic function, defaults glmnet coefficient difference (statistic=\"stat_glmnet\"; see ?stat_glmnet). options include statistic=\"stat_random_forest\" (see ?stat_random_forest), statistic=\"stat_predictive_glmnet\" (see ?stat_predictive_glmnet) statistic=\"stat_predictive_causal_forest\" (see ?stat_predictive_causal_forest). trt binary treatment (factor) variable required statistic involves predictive knockoff filter (.e. statistic=\"stat_predictive_glmnet\" statistic=\"stat_predictive_causal_forest\") adjacency.matrix optional user specified adjacency matrix (.e. binary indicator matrix corresponding non-zero elements precision matrix X). Defaults NULL estimated within function call. ... additional parameters passed \"statistic\" function (note knockoffs parameter X_k entered user; already calculated inside knockoff.statistics function). M number independent knockoff feature statistics calculated.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/dot-knockoff.statistics.single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Knockoff (feature) statistics for a single knockoff — .knockoff.statistics.single","text":"data.frame single knockoff statistics W column.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/eval_fdp.html","id":null,"dir":"Reference","previous_headings":"","what":"False discovery proportion (fdp) as function of selection and known negatives: — eval_fdp","title":"False discovery proportion (fdp) as function of selection and known negatives: — eval_fdp","text":"False discovery proportion (fdp) function selection known negatives:","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/eval_fdp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"False discovery proportion (fdp) as function of selection and known negatives: — eval_fdp","text":"","code":"eval_fdp(selected, negatives)"},{"path":"http://opensource.nibr.com/knockofftools/reference/eval_fdp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"False discovery proportion (fdp) as function of selection and known negatives: — eval_fdp","text":"selected vector indices selected variables negatives vector indices known null variables (influence response)","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/eval_fdp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"False discovery proportion (fdp) as function of selection and known negatives: — eval_fdp","text":"false discovery rate","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/eval_fdp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"False discovery proportion (fdp) as function of selection and known negatives: — eval_fdp","text":"","code":"library(knockofftools)  eval_fdp(selected=c(1,2,3,5), negatives=5:10) #> [1] 0.25"},{"path":"http://opensource.nibr.com/knockofftools/reference/eval_tpp.html","id":null,"dir":"Reference","previous_headings":"","what":"True positive proportion (tpp) as function of selection and known positives: — eval_tpp","title":"True positive proportion (tpp) as function of selection and known positives: — eval_tpp","text":"True positive proportion (tpp) function selection known positives:","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/eval_tpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"True positive proportion (tpp) as function of selection and known positives: — eval_tpp","text":"","code":"eval_tpp(selected, positives)"},{"path":"http://opensource.nibr.com/knockofftools/reference/eval_tpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"True positive proportion (tpp) as function of selection and known positives: — eval_tpp","text":"selected vector indices selected variables negatives vector indices known non-null variables (influence response)","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/eval_tpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"True positive proportion (tpp) as function of selection and known positives: — eval_tpp","text":"true positive rate","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/eval_tpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"True positive proportion (tpp) as function of selection and known positives: — eval_tpp","text":"","code":"#' library(knockofftools)  eval_tpp(selected=c(1,2,3,5), positives=1:4) #> [1] 0.75"},{"path":"http://opensource.nibr.com/knockofftools/reference/find_ratio.html","id":null,"dir":"Reference","previous_headings":"","what":"Ratio from Ren et al. (2021) used to derandomized knockoffs. — find_ratio","title":"Ratio from Ren et al. (2021) used to derandomized knockoffs. — find_ratio","text":"call function .","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/find_ratio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ratio from Ren et al. (2021) used to derandomized knockoffs. — find_ratio","text":"","code":"find_ratio(M, eta)"},{"path":"http://opensource.nibr.com/knockofftools/reference/find_ratio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ratio from Ren et al. (2021) used to derandomized knockoffs. — find_ratio","text":"M number knockoff runs eta proportion runs feature must selected selected overall derandomized procedure.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/find_ratio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ratio from Ren et al. (2021) used to derandomized knockoffs. — find_ratio","text":"returns pre-calculated ratios used multiple knockoff variable selection error.type = \"pfer\" \"kfwer\"","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/find_single_optimal_variable_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Select variables based on (heuristic) mode of multiple variable selections — find_single_optimal_variable_set","title":"Select variables based on (heuristic) mode of multiple variable selections — find_single_optimal_variable_set","text":"call function ","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/find_single_optimal_variable_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select variables based on (heuristic) mode of multiple variable selections — find_single_optimal_variable_set","text":"","code":"find_single_optimal_variable_set(S, p, trim = 0.5)"},{"path":"http://opensource.nibr.com/knockofftools/reference/find_single_optimal_variable_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select variables based on (heuristic) mode of multiple variable selections — find_single_optimal_variable_set","text":"S list variable selection indices p number variables. element list selection indices subset 1:p. trim trimming probability threshold. sensible default trim=0.5.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/find_single_optimal_variable_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select variables based on (heuristic) mode of multiple variable selections — find_single_optimal_variable_set","text":"single \"frequent\" variable selection among multiple selections S.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_X.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Gaussian and binary covariate predictors — generate_X","title":"Simulate Gaussian and binary covariate predictors — generate_X","text":"simulate Gaussian predictors mean zero covariance structure determined \"cov_type\" argument. p_b randomly selected columns dichotomized.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_X.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Gaussian and binary covariate predictors — generate_X","text":"","code":"generate_X(n, p, p_b, cov_type, rho = 0.5)"},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_X.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Gaussian and binary covariate predictors — generate_X","text":"n number observations (rows X) p total number covariates (columns X) continuous binary p_b number binary covariates (0 <= p_b <= p) cov_type character string specifying covariance function. Can one \"cov_diag\" (independent columns), \"cov_equi\" (equi-correlated columns), \"cov_ar1\" (ar1-correlated columns). columns shuffled simulation rho correlation parameter; input cov_type function","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_X.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Gaussian and binary covariate predictors — generate_X","text":"simulated data.frame n rows p columns (p_b binary p-p_b gaussian). column either class \"numeric\" \"factor\".","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_X.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Gaussian and binary covariate predictors — generate_X","text":"function simulates data frame, whose rows multivariate Gaussian mean zero covariance structure determined \"cov_type\" argument. p_b randomly selected columns dichotomized function 1(x>0). continuous columns class \"numeric\" binary columns set class \"factor\".","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_X.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Gaussian and binary covariate predictors — generate_X","text":"","code":"library(knockofftools)  # all columns are continuous: X <- generate_X(n=100, p=6, p_b=0, cov_type=\"cov_equi\", rho=0.5)  round(cor(X), 2) #>      X1   X2   X3   X4   X5   X6 #> X1 1.00 0.51 0.52 0.52 0.57 0.58 #> X2 0.51 1.00 0.49 0.58 0.54 0.47 #> X3 0.52 0.49 1.00 0.60 0.50 0.40 #> X4 0.52 0.58 0.60 1.00 0.60 0.43 #> X5 0.57 0.54 0.50 0.60 1.00 0.50 #> X6 0.58 0.47 0.40 0.43 0.50 1.00  # two of the six columns are dichotomized (and set to class factor): X <- generate_X(n=100, p=6, p_b=2, cov_type=\"cov_equi\", rho=0.5)  # The class of each column: unlist(lapply(X, class)) #>        X1        X2        X3        X4        X5        X6  #>  \"factor\" \"numeric\"  \"factor\" \"numeric\" \"numeric\" \"numeric\""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_lp.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate linear predictor with first p_nn beta coefficients = a, all other = 0 — generate_lp","title":"Generate linear predictor with first p_nn beta coefficients = a, all other = 0 — generate_lp","text":"Generate linear predictor first p_nn beta coefficients = , = 0","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate linear predictor with first p_nn beta coefficients = a, all other = 0 — generate_lp","text":"","code":"generate_lp(X, p_nn, a)"},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_lp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate linear predictor with first p_nn beta coefficients = a, all other = 0 — generate_lp","text":"X data.frame numeric factor columns p_nn number non-null covariate predictors. regression coefficients (beta) corresponding columns 1:p_nn x non-zero, set zero. amplitude non-null regression coefficients","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_lp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate linear predictor with first p_nn beta coefficients = a, all other = 0 — generate_lp","text":"linear predictor X","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_simdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate simulated data set for vignettes — generate_simdata","title":"Generate simulated data set for vignettes — generate_simdata","text":"Generate simulated data set vignettes","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_simdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate simulated data set for vignettes — generate_simdata","text":"","code":"generate_simdata()"},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_simdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate simulated data set for vignettes — generate_simdata","text":"generates simulated data obtained call data(simdata)","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_simdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate simulated data set for vignettes — generate_simdata","text":"","code":"library(knockofftools) data(simdata) all.equal(generate_simdata(), simdata) #> [1] TRUE"},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_y.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Gaussian response from a sparse regression model — generate_y","title":"Simulate Gaussian response from a sparse regression model — generate_y","text":"Simulate Gaussian response sparse regression model","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_y.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Gaussian response from a sparse regression model — generate_y","text":"","code":"generate_y(X, p_nn, a)"},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_y.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Gaussian response from a sparse regression model — generate_y","text":"X data.frame numeric factor columns . p_nn number non-null covariate predictors. regression coefficients (beta) corresponding columns 1:p_nn x non-zero, set zero. amplitude non-null regression coefficients","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_y.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Gaussian response from a sparse regression model — generate_y","text":"simulated Gaussian response regression model y = x x (scaled) model.matrix X.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_y.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Gaussian response from a sparse regression model — generate_y","text":"function takes input data.frame X (created function generate_X) may consist numeric binary factor columns. data frame expanded model matrix x (model.matrix function) subsequently scaled way LASSO scaling. Next simulate y ~ N(x remaining coefficients (p_nn+1):ncol(x) set zero.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/generate_y.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Gaussian response from a sparse regression model — generate_y","text":"","code":"library(knockofftools)  set.seed(1)  # Simulate 4 Gaussian and 2 binary covariate predictors: X <- generate_X(n=100, p=6, p_b=2, cov_type=\"cov_equi\", rho=0.5)  # Simulate response from model y = 2*X[,1] + 2*X[,2] + epsilon, where epsilon ~ N(0,1) y <- generate_y(X, p_nn=2, a=2)"},{"path":"http://opensource.nibr.com/knockofftools/reference/glasso_adjacency_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate adjacency matrix using graphical LASSO (glasso) — glasso_adjacency_matrix","title":"Estimate adjacency matrix using graphical LASSO (glasso) — glasso_adjacency_matrix","text":"Estimate adjacency matrix using graphical LASSO (glasso)","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/glasso_adjacency_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate adjacency matrix using graphical LASSO (glasso) — glasso_adjacency_matrix","text":"","code":"glasso_adjacency_matrix(X)"},{"path":"http://opensource.nibr.com/knockofftools/reference/glasso_adjacency_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate adjacency matrix using graphical LASSO (glasso) — glasso_adjacency_matrix","text":"X data.frame (tibble) covariates","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/glasso_adjacency_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate adjacency matrix using graphical LASSO (glasso) — glasso_adjacency_matrix","text":"adjacency matrix","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoff.html","id":null,"dir":"Reference","previous_headings":"","what":"Knockoffs for general covariate data frames — knockoff","title":"Knockoffs for general covariate data frames — knockoff","text":"Knockoffs general covariate data frames","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Knockoffs for general covariate data frames — knockoff","text":"","code":"knockoff(X, method = \"seq\", ...)"},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Knockoffs for general covariate data frames — knockoff","text":"X data.frame (tibble) \"numeric\" \"factor\" columns . number columns, ncol(X) needs > 2. method type knockoffs calculate. Defaults sequential knockoffs, method=\"seq\", works numeric factor variables. options method=\"sparseseq\", sparse sequential knockoff generation algorithm, method=\"mx\", works columns X continuous. ... additional parameters passed downstream knockoffs generating functions","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Knockoffs for general covariate data frames — knockoff","text":"knockoff copy X","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Knockoffs for general covariate data frames — knockoff","text":"","code":"library(knockofftools)  set.seed(1)  X <- generate_X(n=100, p=6, p_b=2, cov_type=\"cov_equi\", rho=0.5)  # sequential knockoff: Xk <- knockoff(X)  X <- generate_X(n=100, p=6, p_b=0, cov_type=\"cov_equi\", rho=0.5)  # MX-knockoff: Xk <- knockoff(X, method=\"mx\")"},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoff.statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Knockoff (feature) statistics: — knockoff.statistics","title":"Knockoff (feature) statistics: — knockoff.statistics","text":"function calculates M >= 1 independent knockoff (feature) statistics (W) given input response vector y covariate data.frame X. function first calculates M independent knockoff copies (Xk1, ..., XkM) covariate matrix (X) calculates knockoff feature statistics W1, ..., WM. default feature statistic calculated via parameter statistic=knockofftools::stat_glmnet, user may write supply feature statistics functions (e.g. random forest variable importance difference). user may additionally supply fixed effects (X.fixed) always included underlying model (e.g. covariates adjust ).","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoff.statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Knockoff (feature) statistics: — knockoff.statistics","text":"","code":"knockoff.statistics(   y,   X,   type = \"regression\",   M = 1,   knockoff.method = \"seq\",   statistic = \"stat_glmnet\",   trt = NULL,   gcm = TRUE,   ... )"},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoff.statistics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Knockoff (feature) statistics: — knockoff.statistics","text":"y response vector length(y) = nrow(X). Accepts \"numeric\", binary \"factor\", survival (\"Surv\") object. X data.frame (tibble) \"numeric\" \"factor\" columns . number columns, ncol(X) needs > 2. type \"regression\" y numeric, \"classification\" y binary factor variable \"survival\" y survival object. M number independent knockoff feature statistics calculated. knockoff.method type knockoffs calculate. Defaults sequential knockoffs, knockoff.method=\"seq\", options: knockoff.method=\"sparseseq\" knockoff.method=\"mx\". \"mx\" method works columns X matrix continuous. statistic knockoff feature statistic function, defaults glmnet coefficient difference (statistic=\"stat_glmnet\"; see ?stat_glmnet). options include statistic=\"stat_random_forest\" (see ?stat_random_forest), statistic=\"stat_predictive_glmnet\" (see ?stat_predictive_glmnet) statistic=\"stat_predictive_causal_forest\" (see ?stat_predictive_causal_forest). trt binary treatment (factor) variable required statistic involves predictive knockoff filter (.e. statistic=\"stat_predictive_glmnet\" statistic=\"stat_predictive_causal_forest\") gcm logical indicator whether Gaussian Copula Model applied. Defaults TRUE since underlying knockoff generation mechanism numeric variables based multivariate Gaussian variables. gcm=TRUE numeric variable normal score transformed resulting marginal standard normal variables. knockoff filter acts transformed variable space. User advised change parameter unless /understands consequences. ... additional parameters passed \"statistic\" function (note knockoffs parameter X_k entered user; already calculated inside knockoff.statistics function).","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoff.statistics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Knockoff (feature) statistics: — knockoff.statistics","text":"data.frame knockoff statistics W column. number rows matches number columns (variables) data.frame X variable names recorded rownames(W).","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoff.statistics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Knockoff (feature) statistics: — knockoff.statistics","text":"multiple knockoffs desired (M > 1) method utilizes clustermq package parallel distribution jobs HPC scheduler. See clustermq-userguide details configure (differently defaults) clustermq scheduler batch templates.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoff.statistics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Knockoff (feature) statistics: — knockoff.statistics","text":"","code":"library(knockofftools)  set.seed(1)  # Simulate 10 Gaussian covariate predictors: X <- generate_X(n=100, p=10, p_b=0, cov_type=\"cov_equi\", rho=0.2)  # create linear predictor with first 5 beta-coefficients = 1 (all other zero) lp <- generate_lp(X, p_nn = 5, a=1)  # Gaussian  # Simulate response from a linear model y = lp + epsilon, where epsilon ~ N(0,1): y <- lp + rnorm(100)  # Calculate M independent knockoff feature statistics: W <- knockoff.statistics(y=y, X=X, type=\"regression\", M=5) #> Running sequentially ('LOCAL') ... print(variable.selections(W, error.type = \"pfer\", level = 2)$stable.variables) #> [1] \"X1\"  \"X2\"  \"X3\"  \"X4\"  \"X5\"  \"X7\"  \"X10\" if (FALSE) { W <- knockoff.statistics(y=y, X=X, type=\"regression\", M=5, statistic = \"stat_random_forest\") print(variable.selections(W, error.type = \"pfer\", level = 2)$stable.variables)  # Cox  # Simulate from Weibull hazard with with baseline hazard h0(t) = lambda*rho*t^(rho-1) # and linear predictor lp: y <- simulWeib(N=nrow(X), lambda0=0.01, rho=1, lp=lp)  W <- knockoff.statistics(y=y, X=X, type=\"survival\", M=5) print(variable.selections(W, error.type = \"pfer\", level = 2)$stable.variables)  W <- knockoff.statistics(y=y, X=X, type=\"survival\", M=5, statistic = \"stat_random_forest\") print(variable.selections(W, error.type = \"pfer\", level = 2)$stable.variables)  # Check quickly predictive filters # Generate a binary treatment variable trt = sample(c(1,0), nrow(X), replace=TRUE) lp.pred = lp + 1*trt*( as.integer(X[,6]>0) + as.integer(X[,7]>0))  # Gaussian  y <- lp.pred + rnorm(nrow(X))  W <- knockoff.statistics(y=y, X=X, type=\"regression\", statistic = \"stat_predictive_glmnet\", trt=trt, M=5) print(variable.selections(W, error.type = \"pfer\", level = 2)$stable.variables)  W <- knockoff.statistics(y=y, X=X, type=\"regression\", statistic = \"stat_predictive_causal_forest\", trt=trt, M=5) print(variable.selections(W, error.type = \"pfer\", level = 2)$stable.variables)  # Cox  # Simulate from Weibull hazard with with baseline hazard h0(t) = lambda*rho*t^(rho-1) # and linear predictor lp: y <- simulWeib(N=nrow(X), lambda0=0.01, rho=1, lp=lp.pred)  W <- knockoff.statistics(y=y, X=X, type=\"survival\", statistic = \"stat_predictive_glmnet\", trt=trt, M=5) print(variable.selections(W, error.type = \"pfer\", level = 2)$stable.variables)  W <- knockoff.statistics(y=y, X=X, type=\"survival\",                          statistic = \"stat_predictive_causal_forest\",                          trt=trt, M=5) print(variable.selections(W, error.type = \"pfer\", level = 2)$stable.variables)}"},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_mx.html","id":null,"dir":"Reference","previous_headings":"","what":"Gaussian MX-knockoffs for continuous variables — knockoffs_mx","title":"Gaussian MX-knockoffs for continuous variables — knockoffs_mx","text":"Gaussian MX-knockoffs continuous variables","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_mx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gaussian MX-knockoffs for continuous variables — knockoffs_mx","text":"","code":"knockoffs_mx(X)"},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_mx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gaussian MX-knockoffs for continuous variables — knockoffs_mx","text":"X data.frame (tibble) \"numeric\" columns . number columns, ncol(X) needs > 2.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_mx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gaussian MX-knockoffs for continuous variables — knockoffs_mx","text":"Second-order multivariate Gaussian knockoff copy X","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_mx.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gaussian MX-knockoffs for continuous variables — knockoffs_mx","text":"knockoffs_mx performs MX knockoff simulation.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_mx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gaussian MX-knockoffs for continuous variables — knockoffs_mx","text":"","code":"#' library(knockofftools)  set.seed(1)  X <- generate_X(n=100, p=6, p_b=0, cov_type=\"cov_equi\", rho=0.5)  Xk <- knockoffs_mx(X)"},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Sequential knockoffs for continuous and categorical variables — knockoffs_seq","title":"Sequential knockoffs for continuous and categorical variables — knockoffs_seq","text":"Sequential knockoffs continuous categorical variables","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sequential knockoffs for continuous and categorical variables — knockoffs_seq","text":"","code":"knockoffs_seq(X, seq_simulator = sim_glmnet, ...)"},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sequential knockoffs for continuous and categorical variables — knockoffs_seq","text":"X data.frame (tibble) \"numeric\" \"factor\" columns . number columns, ncol(X) needs > 2. seq_simulator function simulates sequential knockoffs. Default function sim_glmnet, simulates response estimated elastic-net model ... parameters passed function seq_simulator. default (elastic-net sequential seq_simulator, seq_simulator = sim_glmnet) parameters passed cv.glmnet.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sequential knockoffs for continuous and categorical variables — knockoffs_seq","text":"sequential knockoff copy X. data.frame tibble type dimensions X.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_seq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sequential knockoffs for continuous and categorical variables — knockoffs_seq","text":"knockoffs_seq performs sequential knockoff simulation using elastic-net regression.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sequential knockoffs for continuous and categorical variables — knockoffs_seq","text":"","code":"library(knockofftools)  set.seed(1)  X <- generate_X(n=100, p=6, p_b=2, cov_type=\"cov_equi\", rho=0.5)  # knockoffs based on sequential elastic-net regression: Xk <- knockoffs_seq(X)"},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_sparse_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Sparse sequential knockoff generation algorithm — knockoffs_sparse_seq","title":"Sparse sequential knockoff generation algorithm — knockoffs_sparse_seq","text":"function takes input data frame X returns sparse sequential knockoff copy. Sparse sequential knockoffs first calculates adjacency matrix X (.e. identifies zeros/non-zeros precision matrix X). proceeds usual sequential knockoffs algorithm, except now sequential regression includes covariates correspond non-zero elements precision matrix X. reduces number covariates per regression original sequential knockoff algorithm. gain additional speed-(compared sequential knockoffs) apply least squares default method estimation regression, unless number covariates exceeds half number observations, .e. p > n/2. case apply elastic net regularized regression.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_sparse_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sparse sequential knockoff generation algorithm — knockoffs_sparse_seq","text":"","code":"knockoffs_sparse_seq(X, adjacency.matrix = NULL)"},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_sparse_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sparse sequential knockoff generation algorithm — knockoffs_sparse_seq","text":"X data.frame (tibble) \"numeric\" \"factor\" columns . number columns, ncol(X) needs > 2. adjacency.matrix optional user specified adjacency matrix (.e. binary indicator matrix corresponding non-zero elements precision matrix X). Defaults NULL estimated within function call. seq_simulator name function used estimate conditional distributions sequential steps. Default function sim_simple, least squares fit (continuous variables) multinomial logistic regression (factor variables) respectively.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_sparse_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sparse sequential knockoff generation algorithm — knockoffs_sparse_seq","text":"sparse sequential knockoff copy X. data.frame tibble type dimensions X.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/knockoffs_sparse_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sparse sequential knockoff generation algorithm — knockoffs_sparse_seq","text":"","code":"library(knockofftools)  set.seed(1)  X <- generate_X(n=100, p=6, p_b=2, cov_type=\"cov_equi\", rho=0.5)  # knockoffs based on sequential elastic-net regression: Xk <- knockoffs_sparse_seq(X) #> # weights:  8 (7 variable) #> initial  value 69.314718  #> iter  10 value 42.911908 #> final  value 42.498721  #> converged #> # weights:  8 (7 variable) #> initial  value 69.314718  #> iter  10 value 48.791354 #> final  value 48.785677  #> converged"},{"path":"http://opensource.nibr.com/knockofftools/reference/multi_select.html","id":null,"dir":"Reference","previous_headings":"","what":"Select variables based on the heuristic multiple selection algorithm from Kormaksson et al. 'Sequential\nknockoffs for continuous and categorical predictors: With application to a large psoriatic arthritis clinical\ntrial pool.' Statistics in Medicine. 2021;1–16. — multi_select","title":"Select variables based on the heuristic multiple selection algorithm from Kormaksson et al. 'Sequential\nknockoffs for continuous and categorical predictors: With application to a large psoriatic arthritis clinical\ntrial pool.' Statistics in Medicine. 2021;1–16. — multi_select","text":"Select variables based heuristic multiple selection algorithm Kormaksson et al. 'Sequential knockoffs continuous categorical predictors: application large psoriatic arthritis clinical trial pool.' Statistics Medicine. 2021;1–16.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/multi_select.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select variables based on the heuristic multiple selection algorithm from Kormaksson et al. 'Sequential\nknockoffs for continuous and categorical predictors: With application to a large psoriatic arthritis clinical\ntrial pool.' Statistics in Medicine. 2021;1–16. — multi_select","text":"","code":"multi_select(S, trim = 0.5)"},{"path":"http://opensource.nibr.com/knockofftools/reference/multi_select.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select variables based on the heuristic multiple selection algorithm from Kormaksson et al. 'Sequential\nknockoffs for continuous and categorical predictors: With application to a large psoriatic arthritis clinical\ntrial pool.' Statistics in Medicine. 2021;1–16. — multi_select","text":"S binary matrix selections trim trimming probability threshold. sensible default trim=0.5.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/multi_select.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select variables based on the heuristic multiple selection algorithm from Kormaksson et al. 'Sequential\nknockoffs for continuous and categorical predictors: With application to a large psoriatic arthritis clinical\ntrial pool.' Statistics in Medicine. 2021;1–16. — multi_select","text":"single \"frequent\" variable selection among multiple selections S.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/multi_select.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select variables based on the heuristic multiple selection algorithm from Kormaksson et al. 'Sequential\nknockoffs for continuous and categorical predictors: With application to a large psoriatic arthritis clinical\ntrial pool.' Statistics in Medicine. 2021;1–16. — multi_select","text":"M. Kormaksson, L. J. Kelly, X. Zhu, S. Haemmerle, L. Pricop, & D. Ohlssen (2021). Sequential knockoffs continuous categorical predictors: application large psoriatic arthritis clinical trial pool. Statistics Medicine, 40(14), 3313-3328.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/multi_select.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select variables based on the heuristic multiple selection algorithm from Kormaksson et al. 'Sequential\nknockoffs for continuous and categorical predictors: With application to a large psoriatic arthritis clinical\ntrial pool.' Statistics in Medicine. 2021;1–16. — multi_select","text":"","code":"library(knockofftools)  set.seed(1)  p = 31 Nknockoff = 100 S <- matrix(sample(0:1,p*Nknockoff, replace=TRUE), p, Nknockoff)  multi_select(S) #> [1]  1  8  9 13 14 15 21 26 28"},{"path":"http://opensource.nibr.com/knockofftools/reference/ns.transform.html","id":null,"dir":"Reference","previous_headings":"","what":"Normal score transformation function — ns.transform","title":"Normal score transformation function — ns.transform","text":"Normal score transformation function","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/ns.transform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normal score transformation function — ns.transform","text":"","code":"ns.transform(y)"},{"path":"http://opensource.nibr.com/knockofftools/reference/ns.transform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normal score transformation function — ns.transform","text":"y numeric vector representing continuous variable","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/ns.transform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normal score transformation function — ns.transform","text":"vector length(y) normal-score transformed variable","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/plot.variable.selections.html","id":null,"dir":"Reference","previous_headings":"","what":"Heatmap of multiple variable selections ordered by importance — plot.variable.selections","title":"Heatmap of multiple variable selections ordered by importance — plot.variable.selections","text":"Heatmap multiple variable selections ordered importance","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/plot.variable.selections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Heatmap of multiple variable selections ordered by importance — plot.variable.selections","text":"","code":"# S3 method for variable.selections plot(S, nbcocluster = c(7, 7))"},{"path":"http://opensource.nibr.com/knockofftools/reference/plot.variable.selections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Heatmap of multiple variable selections ordered by importance — plot.variable.selections","text":"S data.frame variable selections multiple knockoffs (entry either 1 variable selected 0 otherwise). Columns correspond different knockoffs rows correspond underlying variables. row.names(S) records variable names. nbcocluster bivariate vector c(number variable clusters, number selection clusters). former number must specified less nrow(S) latter must less ncol(S).","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/plot.variable.selections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Heatmap of multiple variable selections ordered by importance — plot.variable.selections","text":"plot heatmap","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/plot.variable.selections.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Heatmap of multiple variable selections ordered by importance — plot.variable.selections","text":"help visualize important variables perform clustering selections variables.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/plot.variable.selections.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Heatmap of multiple variable selections ordered by importance — plot.variable.selections","text":"","code":"library(knockofftools)  set.seed(1)  # Simulate 8 Gaussian covariate predictors and 2 binary factors: X <- generate_X(n=100, p=10, p_b=2, cov_type=\"cov_equi\", rho=0.2)  # create linear predictor with first 5 beta-coefficients = 1 (all other zero) lp <- generate_lp(X, p_nn = 5, a=1)  # Gaussian  # Simulate response from a linear model y = lp + epsilon, where epsilon ~ N(0,1): y <- lp + rnorm(100)  # Calculate M independent knockoff feature statistics: W <- knockoff.statistics(y=y, X=X, type=\"regression\", M=5) #> Running sequentially ('LOCAL') ...  S = variable.selections(W, error.type = \"pfer\", level = 1)  # plot heatmap of knockoff selections: plot(S) #> Warning: Vectorized input to `element_text()` is not officially supported. #> ℹ Results may be unexpected or may change in future versions of ggplot2."},{"path":"http://opensource.nibr.com/knockofftools/reference/random_forest_importance_scores.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function called to return the importance scores from random forest — random_forest_importance_scores","title":"Internal function called to return the importance scores from random forest — random_forest_importance_scores","text":"Internal function called return importance scores random forest","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/random_forest_importance_scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function called to return the importance scores from random forest — random_forest_importance_scores","text":"","code":"random_forest_importance_scores(X, y, trt, type = \"regression\", ...)"},{"path":"http://opensource.nibr.com/knockofftools/reference/random_forest_importance_scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function called to return the importance scores from random forest — random_forest_importance_scores","text":"X original data.frame \"numeric\" \"factor\" columns . y response vector length(y) = nrow(X). Accepts \"numeric\" (family=\"gaussian\") binary \"factor\" (family=\"binomial\"). Can also survival object class Surv obtained y = survival::Surv(time, status). type \"regression\" y numeric, \"classification\" y binary factor variable \"survival\" y survival object. ...","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/random_forest_importance_scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function called to return the importance scores from random forest — random_forest_importance_scores","text":"importance scores","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_FDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Controls the false discovery rate (FDR) given knockoff W-statistics. — selections_control_FDR","title":"Controls the false discovery rate (FDR) given knockoff W-statistics. — selections_control_FDR","text":"method introduced Candes et al. (2018)","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_FDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Controls the false discovery rate (FDR) given knockoff W-statistics. — selections_control_FDR","text":"","code":"selections_control_FDR(W, level)"},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_FDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Controls the false discovery rate (FDR) given knockoff W-statistics. — selections_control_FDR","text":"W vector knockoff W-statistics (feature statistics). level nominal level control FDR.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_FDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Controls the false discovery rate (FDR) given knockoff W-statistics. — selections_control_FDR","text":"selected variables","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_FDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Controls the false discovery rate (FDR) given knockoff W-statistics. — selections_control_FDR","text":"E. Candes, Y. Fan, L. Janson, & J. Lv, (2018). Panning gold:‘model‐X’knockoffs high dimensional controlled variable selection. Journal Royal Statistical Society: Series B (Statistical Methodology), 80(3), 551-577.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_FDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Controls the false discovery rate (FDR) given knockoff W-statistics. — selections_control_FDR","text":"","code":"W <- rnorm(100) selections_control_FDR(W, level=0.5) #> integer(0)"},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_PFER.html","id":null,"dir":"Reference","previous_headings":"","what":"Controls the per-familywise error rate (PFER) given knockoff W-statistics. — selections_control_PFER","title":"Controls the per-familywise error rate (PFER) given knockoff W-statistics. — selections_control_PFER","text":"method introduced Janson Su (2016), used implementation https://github.com/zhimeir/derandomized_knockoffs_paper/blob/master/R/pfer_filter.R","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_PFER.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Controls the per-familywise error rate (PFER) given knockoff W-statistics. — selections_control_PFER","text":"","code":"selections_control_PFER(W, level)"},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_PFER.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Controls the per-familywise error rate (PFER) given knockoff W-statistics. — selections_control_PFER","text":"W vector knockoff W-statistics (feature statistics) level nominal level control PFER.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_PFER.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Controls the per-familywise error rate (PFER) given knockoff W-statistics. — selections_control_PFER","text":"selected variables","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_PFER.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Controls the per-familywise error rate (PFER) given knockoff W-statistics. — selections_control_PFER","text":"L. Janson, & W. Su, (2016). Familywise error rate control via knockoffs. Electronic Journal Statistics, 10(1), 960-975.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_PFER.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Controls the per-familywise error rate (PFER) given knockoff W-statistics. — selections_control_PFER","text":"","code":"W <- rnorm(100) selections_control_PFER(W, level=2) #> [1] 91 71 54"},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_kFWER.html","id":null,"dir":"Reference","previous_headings":"","what":"Controls the k-familywise error rate (k-FWER) given a vector of knockoff W-statistics. — selections_control_kFWER","title":"Controls the k-familywise error rate (k-FWER) given a vector of knockoff W-statistics. — selections_control_kFWER","text":"method introduced Janson Su (2016),, used implementation https://github.com/zhimeir/derandomized_knockoffs_paper/blob/master/R/vanilla_fwer_filter.R","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_kFWER.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Controls the k-familywise error rate (k-FWER) given a vector of knockoff W-statistics. — selections_control_kFWER","text":"","code":"selections_control_kFWER(W, level, k)"},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_kFWER.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Controls the k-familywise error rate (k-FWER) given a vector of knockoff W-statistics. — selections_control_kFWER","text":"W vector knockoff W-statistics (feature statistics) level nominal level control k-FWER. k positive integer corresponding k-FWER (multiple testing one seeks control least k false discoveries)","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_kFWER.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Controls the k-familywise error rate (k-FWER) given a vector of knockoff W-statistics. — selections_control_kFWER","text":"selected variables","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_kFWER.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Controls the k-familywise error rate (k-FWER) given a vector of knockoff W-statistics. — selections_control_kFWER","text":"L. Janson, & W. Su, (2016). Familywise error rate control via knockoffs. Electronic Journal Statistics, 10(1), 960-975.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/selections_control_kFWER.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Controls the k-familywise error rate (k-FWER) given a vector of knockoff W-statistics. — selections_control_kFWER","text":"","code":"W <- rnorm(100) selections_control_kFWER(W, level=0.1, k=5) #>  [1]  2 10 59 30  8 77 58 86 74 54 72 39 49"},{"path":"http://opensource.nibr.com/knockofftools/reference/sim_glmnet.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from glmnet penalized regression model — sim_glmnet","title":"Simulate from glmnet penalized regression model — sim_glmnet","text":"Simulate glmnet penalized regression model","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/sim_glmnet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from glmnet penalized regression model — sim_glmnet","text":"","code":"sim_glmnet(y, X, ...)"},{"path":"http://opensource.nibr.com/knockofftools/reference/sim_glmnet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from glmnet penalized regression model — sim_glmnet","text":"y response vector (either \"numeric\" \"factor\") gets passed cv.glmnet X data.frame covariates passed cv.glmnet ... parameters passed function cv.glmnet","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/sim_glmnet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from glmnet penalized regression model — sim_glmnet","text":"simulated response","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/sim_glmnet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from glmnet penalized regression model — sim_glmnet","text":"","code":"library(knockofftools)  set.seed(1)  X = data.frame(matrix(rnorm(100 * 20), 100, 20)) y = X[,1] + rnorm(100)  # simulate from elastic-net regression: ysim = sim_glmnet(y=y, X=X)  # simulated versus input response: plot(y, ysim)"},{"path":"http://opensource.nibr.com/knockofftools/reference/sim_simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple knockoff generator based on least squares fit (continuous variables) or multinomial logistic regression (factor variables) respectively.\nIf X is empty, knockoffs are sampled from the marginal distribution of y — sim_simple","title":"Simple knockoff generator based on least squares fit (continuous variables) or multinomial logistic regression (factor variables) respectively.\nIf X is empty, knockoffs are sampled from the marginal distribution of y — sim_simple","text":"Simple knockoff generator based least squares fit (continuous variables) multinomial logistic regression (factor variables) respectively. X empty, knockoffs sampled marginal distribution y","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/sim_simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple knockoff generator based on least squares fit (continuous variables) or multinomial logistic regression (factor variables) respectively.\nIf X is empty, knockoffs are sampled from the marginal distribution of y — sim_simple","text":"","code":"sim_simple(y, X)"},{"path":"http://opensource.nibr.com/knockofftools/reference/sim_simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple knockoff generator based on least squares fit (continuous variables) or multinomial logistic regression (factor variables) respectively.\nIf X is empty, knockoffs are sampled from the marginal distribution of y — sim_simple","text":"y response vector (either \"numeric\" \"factor\") gets passed cv.glmnet X data.frame covariates passed cv.glmnet","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/sim_simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple knockoff generator based on least squares fit (continuous variables) or multinomial logistic regression (factor variables) respectively.\nIf X is empty, knockoffs are sampled from the marginal distribution of y — sim_simple","text":"simulated response","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/simulWeib.html","id":null,"dir":"Reference","previous_headings":"","what":"Function that simulates response from Cox model with Weibull baseline hazard: — simulWeib","title":"Function that simulates response from Cox model with Weibull baseline hazard: — simulWeib","text":"Function simulates response Cox model Weibull baseline hazard:","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/simulWeib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function that simulates response from Cox model with Weibull baseline hazard: — simulWeib","text":"","code":"simulWeib(N, lambda0, rho, lp)"},{"path":"http://opensource.nibr.com/knockofftools/reference/simulWeib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function that simulates response from Cox model with Weibull baseline hazard: — simulWeib","text":"N sample size lambda0 baseline hazard scale parameter rho baseline hazard shape parameter lp linear predictor","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/simulWeib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function that simulates response from Cox model with Weibull baseline hazard: — simulWeib","text":"survival object simulated event times mild censoring","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/simulWeib.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function that simulates response from Cox model with Weibull baseline hazard: — simulWeib","text":"","code":"# Simulate 10 Gaussian covariate predictors: X <- generate_X(n=100, p=10, p_b=0, cov_type=\"cov_equi\", rho=0.2)  # create linear predictor with first 5 beta-coefficients = 1 (all other zero) lp <- generate_lp(X, p_nn = 5, a=1)  # Simulate from Weibull hazard with with baseline hazard h0(t) = lambda*rho*t^(rho-1) # and linear predictor, whose first 3 coefficients are non-zero: y <- simulWeib(N=nrow(X), lambda0=0.01, rho=1, lp=lp)"},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_glmnet.html","id":null,"dir":"Reference","previous_headings":"","what":"Knockoff (feature) statistics: Absolute elastic-net coefficient differences between original and knockoff variables — stat_glmnet","title":"Knockoff (feature) statistics: Absolute elastic-net coefficient differences between original and knockoff variables — stat_glmnet","text":"function follows mostly implementation knockoff::glmnet.stat_coefdiff. input data.frames (X, X_k) X.fixed (supplied) first converted design matrices (function model.matrix). means input features contain factor variables associated dummy variable determined model.matrix contrasts (defaults indicator dummy variables reference level). call glmnet::cv.glmnet input y x = cbind(X, X_k, X.fixed) penalty applied cbind(X, X_k). user wishes also penalize parameters X.fixed additional penalty.fixed parameter can adjusted accordingly.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_glmnet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Knockoff (feature) statistics: Absolute elastic-net coefficient differences between original and knockoff variables — stat_glmnet","text":"","code":"stat_glmnet(   y,   X,   X_k,   type = \"regression\",   X.fixed = NULL,   penalty.fixed = rep(0, length(X.fixed)),   ... )"},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_glmnet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Knockoff (feature) statistics: Absolute elastic-net coefficient differences between original and knockoff variables — stat_glmnet","text":"y response vector length(y) = nrow(X). Accepts \"numeric\" (type=\"regression\") binary \"factor\" (type=\"classification\"). Can also survival object class \"Surv\" (type=\"survival\") obtained y = survival::Surv(time, status). X original data.frame (tibble) \"numeric\" \"factor\" columns . number columns, ncol(X) needs > 2. X_k knockoff data.frame (tibble) \"numeric\" \"factor\" columns obtained e.g. X_k = knockoff(X). dimensions column classes must match original X. type \"regression\" y numeric, \"classification\" y binary factor variable \"survival\" y survival object. X.fixed data.frame (tibble) \"numeric\" \"factor\" columns corresponding covariates terms treated fixed effects model. penalty.fixed numeric vector length equal number columns X.fixed indicating fixed effects estimated glmnet penalty (1 corresponds covariates penalized 0 corresponds covariates penalized; X.fixed supplied, elements penalty.fixed set zero default) ... additional parameters passed glmnet::cv.glmnet","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_glmnet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Knockoff (feature) statistics: Absolute elastic-net coefficient differences between original and knockoff variables — stat_glmnet","text":"data.frame knockoff statistics W column. number rows matches number columns (variables) data.frame X variable names recorded rownames(W).","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_glmnet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Knockoff (feature) statistics: Absolute elastic-net coefficient differences between original and knockoff variables — stat_glmnet","text":"factor covariates multiple levels among columns X columns model.matrix corresponding data.frame (original X knockoff X_k). case, let W_j difference two maximum absolute signals coefficients model.matrix associated covariate j. .e. j-th variable factor K levels W_j : max(|beta_j1|, ... , |beta_j,K-1|) - max(|beta.tilde_j1|, ..., |beta.tilde_j,K-1|) (beta_j1, ..., beta_j,K-1) (beta.tilde_j1, ..., beta.tilde_j,K-1) coefficients associated dummy variables original j-th factor knockoff, respectively.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_glmnet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Knockoff (feature) statistics: Absolute elastic-net coefficient differences between original and knockoff variables — stat_glmnet","text":"","code":"library(knockofftools)  set.seed(1)  # Simulate 10 Gaussian covariate predictors and 1 factor with 4 levels: X <- generate_X(n=100, p=10, p_b=0, cov_type=\"cov_equi\", rho=0.2)  # Simulate response from a linear model y = X%*%beta + epsilon, where epsilon ~ N(0,1) with # first 3 beta-coefficients = 1 (all other zero): y <- (X$X1 + X$X2 + X$X3) + rnorm(100)  # Calculate M independent knockoff feature statistics: W <- knockoff.statistics(y=y, X=X)"},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_causal_forest.html","id":null,"dir":"Reference","previous_headings":"","what":"Causal forest based knockoff (feature) statistics that captues the predictive strength: Difference from importance scores derived by causal forest — stat_predictive_causal_forest","title":"Causal forest based knockoff (feature) statistics that captues the predictive strength: Difference from importance scores derived by causal forest — stat_predictive_causal_forest","text":"filter presented Sechidis et al. (2021).","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_causal_forest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Causal forest based knockoff (feature) statistics that captues the predictive strength: Difference from importance scores derived by causal forest — stat_predictive_causal_forest","text":"","code":"stat_predictive_causal_forest(X, X_k, y, trt, type = \"regression\", ...)"},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_causal_forest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Causal forest based knockoff (feature) statistics that captues the predictive strength: Difference from importance scores derived by causal forest — stat_predictive_causal_forest","text":"X original data.frame (tibble) \"numeric\" \"factor\" columns . number columns, ncol(X) needs > 2. X_k knockoff data.frame (tibble) \"numeric\" \"factor\" columns obtained e.g. X_k = knockoff(X). dimensions column classes must match original X. y response vector length(y) = nrow(X). Accepts \"numeric\" (type=\"regression\") binary \"factor\" (type=\"classification\"). Can also survival object class \"Surv\" (type=\"survival\") obtained y = survival::Surv(time, status). trt binary treatment indicator variable (numeric 0/1 entries) type \"regression\" y numeric, \"classification\" y binary factor variable \"survival\" y survival object. ... additional parameters passed grf::causal_forest (type = \"regression\" \"classification) causal_survival_forest (type = \"survival\")","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_causal_forest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Causal forest based knockoff (feature) statistics that captues the predictive strength: Difference from importance scores derived by causal forest — stat_predictive_causal_forest","text":"data.frame knockoff statistics W column capture predictive strength variables. number rows matches number columns (variables) data.frame X variable names recorded rownames(W).","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_causal_forest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Causal forest based knockoff (feature) statistics that captues the predictive strength: Difference from importance scores derived by causal forest — stat_predictive_causal_forest","text":"factor covariates multiple levels among columns X columns model.matrix corresponding data.frame (original X knockoff X_k). case, let W_j difference two sums derived variable importance (VI) scores associated covariate j. .e. j-th variable factor K levels W_j : sum(|VI_j,1|, ... , |VI_j,K|) - sum(|VI_j1|, ..., |VI_j,K|). Sechidis, K., Kormaksson, M., & Ohlssen, D. (2021). Using knockoffs controlled predictive biomarker identification. Statistics Medicine, 40(25), 5453-5473.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_causal_forest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Causal forest based knockoff (feature) statistics that captues the predictive strength: Difference from importance scores derived by causal forest — stat_predictive_causal_forest","text":"","code":"library(knockofftools)  set.seed(1)  # Simulate 10 Gaussian covariate predictors and 1 factor with 4 levels: X <- generate_X(n=500, p=10, p_b=0, cov_type=\"cov_diag\", rho=0.2) X$X11 <- factor(sample(c(\"A\",\"B\",\"C\",\"D\"), nrow(X), replace=TRUE))   # Calculate the knockoff copy of X: X_k <- knockoff(X)  # Generate a binary treatment variable trt = sample(c(1,0), nrow(X), replace=TRUE)  # Simulate a fixed \"treatment\" effect: X.fixed <- data.frame(SEX = factor(sample(c(\"male\", \"female\"), nrow(X), replace=TRUE)), trt = trt) penalty.fixed = rep(0, length(X.fixed))  # create linear predictor with first 3 beta-coefficients = 1 (all other zero) and a treatment effect of size 1 lp <- X.fixed$trt+ as.numeric(X.fixed$SEX == 'male') + (X$X1 + X$X2 + X$X3) + (X$X4 + as.integer(X$X11=='A'))*trt  # Gaussian  # Simulate response from a linear model y = lp + epsilon, where epsilon ~ N(0,1): y <- lp + rnorm(nrow(X))  W <- stat_predictive_causal_forest(X=X, X_k=X_k, y=y, trt=trt, type=\"regression\")  # Cox  # Simulate from Weibull hazard with with baseline hazard h0(t) = lambda*rho*t^(rho-1) # and linear predictor lp: y <- simulWeib(N=nrow(X), lambda0=0.01, rho=1, lp=lp)  W <- stat_predictive_causal_forest(X=X, X_k=X_k, y=y, trt=trt, type=\"survival\")"},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_glmnet.html","id":null,"dir":"Reference","previous_headings":"","what":"Knockoff (feature) statistics that captues the predictive strength: Absolute coefficient differences between treatment original variables interaction terms and treatment knockoff variables interaction terms — stat_predictive_glmnet","title":"Knockoff (feature) statistics that captues the predictive strength: Absolute coefficient differences between treatment original variables interaction terms and treatment knockoff variables interaction terms — stat_predictive_glmnet","text":"function follows implementation stat_glmnet function, modifies focus coefficients interaction terms treatment. first version filter suggested Sechidis et al. (2021), function also allow user adjust variables, fix variables prognostic model.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_glmnet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Knockoff (feature) statistics that captues the predictive strength: Absolute coefficient differences between treatment original variables interaction terms and treatment knockoff variables interaction terms — stat_predictive_glmnet","text":"","code":"stat_predictive_glmnet(   X,   X_k,   y,   trt,   type = \"regression\",   X.fixed = NULL,   penalty.fixed = rep(0, length(X.fixed)),   fixed.prognostic = FALSE,   ... )"},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_glmnet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Knockoff (feature) statistics that captues the predictive strength: Absolute coefficient differences between treatment original variables interaction terms and treatment knockoff variables interaction terms — stat_predictive_glmnet","text":"X original data.frame (tibble) \"numeric\" \"factor\" columns . number columns, ncol(X) needs > 2. X_k knockoff data.frame (tibble) \"numeric\" \"factor\" columns obtained e.g. X_k = knockoff(X). dimensions column classes must match original X. y response vector length(y) = nrow(X). Accepts \"numeric\" (type=\"regression\") binary \"factor\" (type=\"classification\"). Can also survival object class \"Surv\" (type=\"survival\") obtained y = survival::Surv(time, status). trt binary treatment indicator variable (numeric 0/1 entries) type \"regression\" y numeric, \"classification\" y binary factor variable \"survival\" y survival object. X.fixed data.frame (tibble) \"numeric\" \"factor\" columns corresponding covariates terms treated fixed effects model. penalty.fixed numeric vector length equal number columns X.fixed indicating fixed effects estimated glmnet penalty (1 corresponds covariates penalized 0 corresponds covariates penalized; X.fixed supplied, elements penalty.fixed set zero default) fixed.prognostic parameters describes weather user fix prognostic variable model (TRUE) (FALSE) ... additional parameters passed glmnet::cv.glmnet","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_glmnet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Knockoff (feature) statistics that captues the predictive strength: Absolute coefficient differences between treatment original variables interaction terms and treatment knockoff variables interaction terms — stat_predictive_glmnet","text":"data.frame knockoff statistics W column capture predictive strength variables. number rows matches number columns (variables) data.frame X variable names recorded rownames(W).","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_glmnet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Knockoff (feature) statistics that captues the predictive strength: Absolute coefficient differences between treatment original variables interaction terms and treatment knockoff variables interaction terms — stat_predictive_glmnet","text":"factor covariates multiple levels among columns X columns model.matrix corresponding data.frame (original X knockoff X_k). case, let W_j difference two maximum absolute signals coefficients model.matrix associated covariate j. .e. j-th variable factor K levels W_j : max(|beta_j1|, ... , |beta_j,K-1|) - max(|beta.tilde_j1|, ..., |beta.tilde_j,K-1|) (beta_j1, ..., beta_j,K-1) (beta.tilde_j1, ..., beta.tilde_j,K-1) coefficients associated dummy variables original j-th factor knockoff, respectively. Sechidis, K., Kormaksson, M., & Ohlssen, D. (2021). Using knockoffs controlled predictive biomarker identification. Statistics Medicine, 40(25), 5453-5473.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_predictive_glmnet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Knockoff (feature) statistics that captues the predictive strength: Absolute coefficient differences between treatment original variables interaction terms and treatment knockoff variables interaction terms — stat_predictive_glmnet","text":"","code":"if (FALSE) { library(knockofftools)  set.seed(1)  # Simulate 10 Gaussian covariate predictors and 1 factor with 4 levels: X <- generate_X(n=500, p=10, p_b=0, cov_type=\"cov_diag\", rho=0.2) X$X11 <- factor(sample(c(\"A\",\"B\",\"C\",\"D\"), nrow(X), replace=TRUE))   # Calculate the knockoff copy of X: X_k <- knockoff(X)  # Generate a binary treatment variable trt = sample(c(1,0), nrow(X), replace=TRUE)  # Simulate a fixed \"treatment\" effect: X.fixed <- data.frame(SEX = factor(sample(c(\"male\", \"female\"), nrow(X), replace=TRUE)), trt = trt) penalty.fixed = rep(0, length(X.fixed))  # create linear predictor with first 3 beta-coefficients = 1 (all other zero) and a treatment effect of size 1 lp <- X.fixed$trt+ as.numeric(X.fixed$SEX == 'male') + (X$X1 + X$X2 + X$X3) + (X$X4 + 2*as.integer(X$X11=='A'))*trt  # Gaussian  # Simulate response from a linear model y = lp + epsilon, where epsilon ~ N(0,1): y <- lp + rnorm(nrow(X))  # We present three different ways of using that filter # (a) the filter suggested in Sechidis et al. (2021) - where there is no fixed prognostic part W <- stat_predictive_glmnet(y=y, trt=trt, X=X, X_k=X_k, type=\"regression\", X.fixed=X.fixed, penalty.fixed = penalty.fixed, fixed.prognostic = FALSE) # (b) a variation where the user can fix some prognostic variables in the model and allows the model to penalise them X.fixed.prognostic <- data.frame( X1 = X$X1, X2 = X$X2, X3 = X$X3) penalty.fixed.prognostic = rep(1, length(X.fixed.prognostic)) W <- stat_predictive_glmnet(y=y, trt=trt, X=X, X_k=X_k, type=\"regression\", X.fixed=cbind(X.fixed, X.fixed.prognostic),  penalty.fixed = c(penalty.fixed,penalty.fixed.prognostic), fixed.prognostic = TRUE)  # Cox  # Simulate from Weibull hazard with with baseline hazard h0(t) = lambda*rho*t^(rho-1) and linear predictor lp: y <- simulWeib(N=nrow(X), lambda0=0.01, rho=1, lp=lp)  # Explore the three scenarios above with survival outcomes # (a) the filter suggested in Sechidis et al. (2021) - where there is no fixed prognostic part W <- stat_predictive_glmnet(y=y, trt=trt, X=X, X_k=X_k, type=\"survival\", X.fixed=X.fixed, penalty.fixed = penalty.fixed, fixed.prognostic = FALSE) # (b) a variation where the user can fix some prognostic variables in the model and allows the model to penalise them X.fixed.prognostic <- data.frame( X1 = X$X1, X2 = X$X2, X3 = X$X3) penalty.fixed.prognostic = rep(1, length(X.fixed.prognostic)) W <- stat_predictive_glmnet(y=y, trt=trt, X=X, X_k=X_k, type=\"survival\", X.fixed=cbind(X.fixed, X.fixed.prognostic),  penalty.fixed = c(penalty.fixed,penalty.fixed.prognostic), fixed.prognostic = TRUE) }"},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_random_forest.html","id":null,"dir":"Reference","previous_headings":"","what":"Knockoff (feature) statistics: Random forest — stat_random_forest","title":"Knockoff (feature) statistics: Random forest — stat_random_forest","text":"function uses randomForestSRC package estimate importance scores random forest.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_random_forest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Knockoff (feature) statistics: Random forest — stat_random_forest","text":"","code":"stat_random_forest(X, X_k, y, type = \"regression\", ...)"},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_random_forest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Knockoff (feature) statistics: Random forest — stat_random_forest","text":"X original data.frame (tibble) \"numeric\" \"factor\" columns . number columns, ncol(X) needs > 2. X_k knockoff data.frame (tibble) \"numeric\" \"factor\" columns obtained e.g. X_k = knockoff(X). dimensions column classes must match original X. y response vector length(y) = nrow(X). Accepts \"numeric\" (family=\"gaussian\") binary \"factor\" (family=\"binomial\"). Can also survival object class \"Surv\" (type=\"survival\") obtained y = survival::Surv(time, status). type \"regression\" y numeric, \"classification\" y binary factor variable \"survival\" y survival object. ...","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_random_forest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Knockoff (feature) statistics: Random forest — stat_random_forest","text":"data.frame knockoff statistics W column. number rows matches number columns (variables) data.frame X variable names recorded rownames(W).","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_random_forest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Knockoff (feature) statistics: Random forest — stat_random_forest","text":"factor covariates multiple levels among columns X columns model.matrix corresponding data.frame (original X knockoff X_k). case, let W_j difference two sums derived variable importance (VI) scores associated covariate j. .e. j-th variable factor K levels W_j : sum(|VI_j,1|, ... , |VI_j,K|) - sum(|VI_j1|, ..., |VI_j,K|).","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/stat_random_forest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Knockoff (feature) statistics: Random forest — stat_random_forest","text":"","code":"library(knockofftools)  set.seed(1)  # Simulate 10 Gaussian covariate predictors and 1 factor with 4 levels: X <- generate_X(n=500, p=10, p_b=0, cov_type=\"cov_diag\", rho=0.2) X$X11 <- factor(sample(c(\"A\",\"B\",\"C\",\"D\"), nrow(X), replace=TRUE))  # Calculate the knockoff copy of X: X_k <- knockoff(X)  # create linear predictor with first 3 beta-coefficients = 1 (all other zero) and a treatment effect of size 1 lp <- (X$X1 + X$X2 + X$X3)  # Gaussian  # Simulate response from a linear model y = lp + epsilon, where epsilon ~ N(0,1): y <- lp + rnorm(nrow(X))  W <- stat_random_forest(X, X_k, y, type = \"regression\")  # Cox  # Simulate from Weibull hazard with with baseline hazard h0(t) = lambda*rho*t^(rho-1) and linear predictor lp: y <- simulWeib(N=nrow(X), lambda0=0.01, rho=1, lp=lp)  # Calculate  knockoff feature statistics: W <- stat_random_forest(X, X_k, y, type = \"survival\")"},{"path":"http://opensource.nibr.com/knockofftools/reference/variable.selections.html","id":null,"dir":"Reference","previous_headings":"","what":"Knockoff variable selection: Select the variables by controlling a user-specified error rate — variable.selections","title":"Knockoff variable selection: Select the variables by controlling a user-specified error rate — variable.selections","text":"main function performs knockoff based variable selection using input knockoff statistics W. case multiple knockoffs, ncol(W) > 1, function performs variable selection knockoff additionally stabilizes selections combining outcomes.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/variable.selections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Knockoff variable selection: Select the variables by controlling a user-specified error rate — variable.selections","text":"","code":"variable.selections(W, level = 0.2, error.type = \"fdr\", k = NULL, thres = 0.5)"},{"path":"http://opensource.nibr.com/knockofftools/reference/variable.selections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Knockoff variable selection: Select the variables by controlling a user-specified error rate — variable.selections","text":"W data.frame knockoff W-statistics (feature statistics); columns correspond different knockoffs rows correspond underlying variables. row.names(W) records variable names. level nominal level user wants control error.type error rate control, moment \"fdr\", \"pfer\" \"kfwer\" k positive integer corresponding k-FWER (multiple testing one seeks control least k false discoveries), used error.type = 'kfwer' thres threshold parameter stabilizing selections (eta parameter derandomized knockoffs, trims parameter multi_select). natural choice thres = 0.5.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/variable.selections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Knockoff variable selection: Select the variables by controlling a user-specified error rate — variable.selections","text":"object class \"variable.selections\" essentially list two elements: 1) $selections = (p x M) binary data.frame rows correspond variables, cols correspond different knockoffs; value 1 means given variable selected particular knockoff simulation, 0 otherwise; 2) $stable.selection =  character vector selected variables stability selection (described Details). second field meaningful user specifies multiple knockoffs (say M > 5). M = 1 stable.selection simply returns indicies $selections equal 1.","code":""},{"path":"http://opensource.nibr.com/knockofftools/reference/variable.selections.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Knockoff variable selection: Select the variables by controlling a user-specified error rate — variable.selections","text":"Knockoffs randomized procedure relies construction synthetic (knockoff) variables. function performs variable selection multiple knockoffs stabilizes selections combining outcomes. pfer kfwer error controlled derandomizing knockoffs used, introduced Ret et al. (2021) provably controls errors. fdr controlled heuristic multiple selection algorithm used, introduced Kormaksson et al. (2021). Z. Ren, Y. Wei, & E. Candès, (2021). Derandomizing knockoffs. Journal American Statistical Association, 1-11. M. Kormaksson, L. J. Kelly, X. Zhu, S. Haemmerle, L. Pricop, & D. Ohlssen (2021). Sequential knockoffs continuous categorical predictors: application large psoriatic arthritis clinical trial pool. Statistics Medicine, 40(14), 3313-3328.","code":""},{"path":[]},{"path":"http://opensource.nibr.com/knockofftools/reference/variable.selections.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Knockoff variable selection: Select the variables by controlling a user-specified error rate — variable.selections","text":"","code":"library(knockofftools)  set.seed(1)  # Simulate 10 Gaussian covariate predictors: X <- generate_X(n=100, p=10, p_b=0, cov_type=\"cov_equi\", rho=0.2)  # create linear predictor with first 5 beta-coefficients = 1 (all other zero) lp <- generate_lp(X, p_nn = 5, a=1)  # Gaussian  # Simulate response from a linear model y = lp + epsilon, where epsilon ~ N(0,1): y <- lp + rnorm(100)  # Calculate M independent knockoff feature statistics: W <- knockoff.statistics(y=y, X=X, type=\"regression\", M=5) #> Running sequentially ('LOCAL') ...  S = variable.selections(W, error.type = \"pfer\", level = 1)  # selections under alternative error control: S = variable.selections(W, error.type = \"kfwer\", k=1, level = 0.50) S = variable.selections(W, error.type = \"fdr\", level = 0.5)"}]
